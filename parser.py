from mipper import *
from ops import *

# Begin -- grammar generated by Yapps
import sys, re
import yapps.yappsrt as yappsrt

class MipsParserScanner(yappsrt.Scanner):
    patterns = [
        ('"mfhi"', re.compile('mfhi')),
        ('"div"', re.compile('div')),
        ('"move"', re.compile('move')),
        ('"jr"', re.compile('jr')),
        ('"jal"', re.compile('jal')),
        ('"la"', re.compile('la')),
        ('"blt"', re.compile('blt')),
        ('"bne"', re.compile('bne')),
        ('"beq"', re.compile('beq')),
        ('"j"', re.compile('j')),
        ('"li"', re.compile('li')),
        ('"addi"', re.compile('addi')),
        ('","', re.compile(',')),
        ('"add"', re.compile('add')),
        ('"\\\\)"', re.compile('\\)')),
        ('"\\\\("', re.compile('\\(')),
        ('".asciiz"', re.compile('.asciiz')),
        ('"\\n"', re.compile('\n')),
        ('".text\\n"', re.compile('.text\n')),
        ('".data\\n"', re.compile('.data\n')),
        (' ', re.compile(' ')),
        ('END', re.compile('$')),
        ('NUM', re.compile('[0-9]+')),
        ('HEX', re.compile('0x[0-9]+')),
        ('REGISTER', re.compile('\\$(gp|sp|fp|ra|v[0-1]|a[0-3]|t[0-9]|s[0-7]|k[0-1]|zero)')),
        ('LABEL', re.compile('\\w+:')),
        ('LABEL_REF', re.compile('\\w+')),
        ('SYSCALL', re.compile('syscall')),
        ('STRING', re.compile('"[^"]*"')),
    ]
    def __init__(self, str):
        yappsrt.Scanner.__init__(self,None,[' '],str)

class MipsParser(yappsrt.Parser):
    Context = yappsrt.Context
    def program(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'program', [])
        _token = self._peek('".data\\n"', '".text\\n"')
        if _token == '".data\\n"':
            data = self.data(_context)
            text = self.text(_context)
            ret = data, text
        else: # == '".text\\n"'
            text = self.text(_context)
            data = self.data(_context)
            ret = data, text
        END = self._scan('END')
        return ret

    def data(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'data', [])
        self._scan('".data\\n"')
        allocations = {}
        while self._peek('LABEL', '".text\\n"', 'END') == 'LABEL':
            allocation = self.allocation(_context)
            allocations.update(allocation)
        if self._peek() not in ['LABEL', '".text\\n"', 'END']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['LABEL', '".text\\n"', 'END']))
        return allocations

    def text(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'text', [])
        self._scan('".text\\n"')
        lines = []
        while 1:
            _token = self._peek('LABEL', 'SYSCALL', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"')
            if _token not in ['LABEL', 'SYSCALL']:
                statement = self.statement(_context)
                lines.append(statement)
            elif _token == 'LABEL':
                LABEL = self._scan('LABEL')
                self._scan('"\\n"')
                lines.append(LABEL.strip(':'))
            else: # == 'SYSCALL'
                SYSCALL = self._scan('SYSCALL')
                self._scan('"\\n"')
                lines.append(SYSCALL)
            if self._peek('LABEL', 'SYSCALL', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '".data\\n"', 'END') not in ['LABEL', 'SYSCALL', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"']: break
        return lines

    def allocation(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'allocation', [])
        LABEL = self._scan('LABEL')
        if self._peek('".asciiz"', 'STRING', 'NUM', 'HEX') == '".asciiz"':
            self._scan('".asciiz"')
        _token = self._peek('STRING', 'NUM', 'HEX')
        if _token != 'STRING':
            immediate = self.immediate(_context)
            value = immediate
        else: # == 'STRING'
            STRING = self._scan('STRING')
            value = STRING
        self._scan('"\\n"')
        return [[LABEL.strip(':'), value.strip('"')]]

    def statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'statement', [])
        _token = self._peek('"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"')
        if _token == '"add"':
            add_op = self.add_op(_context)
            ret = add_op
        elif _token == '"addi"':
            addi_op = self.addi_op(_context)
            ret = addi_op
        elif _token == '"li"':
            li_op = self.li_op(_context)
            ret = li_op
        elif _token == '"j"':
            j_op = self.j_op(_context)
            ret = j_op
        elif _token == '"beq"':
            beq_op = self.beq_op(_context)
            ret = beq_op
        elif _token == '"bne"':
            bne_op = self.bne_op(_context)
            ret = bne_op
        elif _token == '"blt"':
            blt_op = self.blt_op(_context)
            ret = blt_op
        elif _token == '"la"':
            la_op = self.la_op(_context)
            ret = la_op
        elif _token == '"jal"':
            jal_op = self.jal_op(_context)
            ret = jal_op
        elif _token == '"jr"':
            jr_op = self.jr_op(_context)
            ret = jr_op
        elif _token == '"move"':
            move_op = self.move_op(_context)
            ret = move_op
        elif _token == '"div"':
            div_op = self.div_op(_context)
            ret = div_op
        else: # == '"mfhi"'
            mfhi_op = self.mfhi_op(_context)
            ret = mfhi_op
        self._scan('"\\n"')
        return ret

    def immediate(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'immediate', [])
        _token = self._peek('NUM', 'HEX')
        if _token == 'NUM':
            NUM = self._scan('NUM')
            return int(NUM, 10)
        else: # == 'HEX'
            HEX = self._scan('HEX')
            return int(HEX, 16)

    def indirect_address(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'indirect_address', [])
        offset = 0
        if self._peek('NUM', '"\\\\("') == 'NUM':
            NUM = self._scan('NUM')
            offset = NUM
        self._scan('"\\\\("')
        REGISTER = self._scan('REGISTER')
        reg = REGISTER
        self._scan('"\\\\)"')
        return (offset, register)

    def add_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'add_op', [])
        self._scan('"add"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg2 = REGISTER
        return ADD(dst, reg1, reg2)

    def addi_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'addi_op', [])
        self._scan('"addi"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        immediate = self.immediate(_context)
        imm = immediate
        return ADDI(dst, reg1, imm)

    def li_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'li_op', [])
        self._scan('"li"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        immediate = self.immediate(_context)
        imm = immediate
        return LI(dst, imm)

    def j_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'j_op', [])
        self._scan('"j"')
        LABEL_REF = self._scan('LABEL_REF')
        return JUMP(LABEL_REF)

    def beq_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'beq_op', [])
        self._scan('"beq"')
        REGISTER = self._scan('REGISTER')
        arg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        arg2 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        arg3 = LABEL_REF
        return BEQ(arg1, arg2, arg3)

    def bne_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'bne_op', [])
        self._scan('"bne"')
        REGISTER = self._scan('REGISTER')
        arg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        arg2 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        arg3 = LABEL_REF
        return BNE(arg1, arg2, arg3)

    def blt_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'blt_op', [])
        self._scan('"blt"')
        REGISTER = self._scan('REGISTER')
        arg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        arg2 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        arg3 = LABEL_REF
        return BLT(arg1, arg2, arg3)

    def la_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'la_op', [])
        self._scan('"la"')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        address = LABEL_REF
        return LA(reg1, address)

    def jal_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'jal_op', [])
        self._scan('"jal"')
        LABEL_REF = self._scan('LABEL_REF')
        return JAL(LABEL_REF)

    def jr_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'jr_op', [])
        self._scan('"jr"')
        REGISTER = self._scan('REGISTER')
        return JR(REGISTER)

    def move_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'move_op', [])
        self._scan('"move"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        src = REGISTER
        return MOVE(dst, src)

    def div_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'div_op', [])
        self._scan('"div"')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg2 = REGISTER
        return DIV(reg1, reg2)

    def mfhi_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'mfhi_op', [])
        self._scan('"mfhi"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        return MFHI(dst)


def parse(rule, text):
    P = MipsParser(MipsParserScanner(text))
    return yappsrt.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
