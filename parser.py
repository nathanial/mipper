from mipper import *
from ops import *

# Begin -- grammar generated by Yapps
import sys, re
import yapps.yappsrt as yappsrt

class MipsParserScanner(yappsrt.Scanner):
    patterns = [
        ('"sw"', re.compile('sw')),
        ('"lw"', re.compile('lw')),
        ('"mfhi"', re.compile('mfhi')),
        ('"div"', re.compile('div')),
        ('"move"', re.compile('move')),
        ('"jr"', re.compile('jr')),
        ('"jal"', re.compile('jal')),
        ('"la"', re.compile('la')),
        ('"blt"', re.compile('blt')),
        ('"bne"', re.compile('bne')),
        ('"beq"', re.compile('beq')),
        ('"j"', re.compile('j')),
        ('"li"', re.compile('li')),
        ('"addi"', re.compile('addi')),
        ('","', re.compile(',')),
        ('"add"', re.compile('add')),
        ('"\\\\)"', re.compile('\\)')),
        ('"\\\\("', re.compile('\\(')),
        ('".space"', re.compile('.space')),
        ('".asciiz"', re.compile('.asciiz')),
        ('".text\\n"', re.compile('.text\n')),
        ('".data\\n"', re.compile('.data\n')),
        ('"\\n"', re.compile('\n')),
        (' ', re.compile(' ')),
        ('END', re.compile('$')),
        ('NUM', re.compile('-?[0-9]+')),
        ('HEX', re.compile('0x[0-9]+')),
        ('REGISTER', re.compile('\\$(gp|sp|fp|ra|v[0-1]|a[0-3]|t[0-9]|s[0-7]|k[0-1]|zero)')),
        ('LABEL', re.compile('\\w+:')),
        ('LABEL_REF', re.compile('\\w+')),
        ('SYSCALL', re.compile('syscall')),
        ('STRING', re.compile('"[^"]*"')),
        ('COMMENT', re.compile('#[^\n]*\n')),
    ]
    def __init__(self, str):
        yappsrt.Scanner.__init__(self,None,[' '],str)

class MipsParser(yappsrt.Parser):
    Context = yappsrt.Context
    def end_line(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'end_line', [])
        _token = self._peek('"\\n"', 'COMMENT')
        if _token == '"\\n"':
            self._scan('"\\n"')
        else: # == 'COMMENT'
            COMMENT = self._scan('COMMENT')

    def empty_line(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'empty_line', [])
        end_line = self.end_line(_context)

    def program(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'program', [])
        while self._peek('"\\n"', 'COMMENT', '".data\\n"', '".text\\n"', 'LABEL', 'SYSCALL', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"', 'END') in ['"\\n"', 'COMMENT']:
            empty_line = self.empty_line(_context)
        if self._peek() not in ['"\\n"', 'COMMENT', '".data\\n"', '".text\\n"', 'LABEL', 'SYSCALL', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"', 'END']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['"\\n"', 'COMMENT', '".data\\n"', '".text\\n"', 'LABEL', 'SYSCALL', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"', 'END']))
        _token = self._peek('".data\\n"', '".text\\n"')
        if _token == '".data\\n"':
            data = self.data(_context)
            text = self.text(_context)
            ret = data, text
        else: # == '".text\\n"'
            text = self.text(_context)
            data = self.data(_context)
            ret = data, text
        END = self._scan('END')
        return ret

    def data(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'data', [])
        self._scan('".data\\n"')
        allocations = []
        while self._peek('"\\n"', 'COMMENT', 'LABEL', 'SYSCALL', '".data\\n"', '".text\\n"', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"', 'END') in ['"\\n"', 'COMMENT', 'LABEL']:
            _token = self._peek('"\\n"', 'COMMENT', 'LABEL')
            if _token == 'LABEL':
                allocation = self.allocation(_context)
                allocations.append(allocation)
            else: # in ['"\\n"', 'COMMENT']
                empty_line = self.empty_line(_context)
        if self._peek() not in ['"\\n"', 'COMMENT', 'LABEL', 'SYSCALL', '".data\\n"', '".text\\n"', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"', 'END']:
            raise yappsrt.SyntaxError(charpos=self._scanner.get_prev_char_pos(), context=_context, msg='Need one of ' + ', '.join(['"\\n"', 'COMMENT', 'LABEL', 'SYSCALL', '".data\\n"', '".text\\n"', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"', 'END']))
        return allocations

    def text(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'text', [])
        self._scan('".text\\n"')
        lines = []
        while 1:
            _token = self._peek('LABEL', 'SYSCALL', '"\\n"', 'COMMENT', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"')
            if _token not in ['LABEL', 'SYSCALL', '"\\n"', 'COMMENT']:
                statement = self.statement(_context)
                lines.append(statement)
            elif _token == 'LABEL':
                LABEL = self._scan('LABEL')
                end_line = self.end_line(_context)
                lines.append(LABEL.strip(':'))
            elif _token == 'SYSCALL':
                SYSCALL = self._scan('SYSCALL')
                end_line = self.end_line(_context)
                lines.append(SYSCALL)
            else: # in ['"\\n"', 'COMMENT']
                empty_line = self.empty_line(_context)
            if self._peek('LABEL', 'SYSCALL', '"\\n"', 'COMMENT', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"', '".data\\n"', '".text\\n"', 'END') not in ['LABEL', 'SYSCALL', '"\\n"', 'COMMENT', '"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"']: break
        return lines

    def allocation(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'allocation', [])
        LABEL = self._scan('LABEL')
        _token = self._peek('".asciiz"', '".space"')
        if _token == '".asciiz"':
            allocate_asciiz = self.allocate_asciiz(_context)
            f = allocate_asciiz
        else: # == '".space"'
            allocate_space = self.allocate_space(_context)
            f = allocate_space
        end_line = self.end_line(_context)
        return f(LABEL.strip(':'))

    def allocate_asciiz(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'allocate_asciiz', [])
        self._scan('".asciiz"')
        STRING = self._scan('STRING')
        str_val = STRING
        return lambda lbl : CREATE_STRING(lbl, str_val)

    def allocate_space(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'allocate_space', [])
        self._scan('".space"')
        NUM = self._scan('NUM')
        nsize = NUM
        return lambda lbl : CREATE_SPACE(lbl, nsize)

    def statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'statement', [])
        _token = self._peek('"add"', '"addi"', '"li"', '"j"', '"beq"', '"bne"', '"blt"', '"la"', '"jal"', '"jr"', '"move"', '"div"', '"mfhi"', '"lw"', '"sw"')
        if _token == '"add"':
            add_op = self.add_op(_context)
            ret = add_op
        elif _token == '"addi"':
            addi_op = self.addi_op(_context)
            ret = addi_op
        elif _token == '"li"':
            li_op = self.li_op(_context)
            ret = li_op
        elif _token == '"j"':
            j_op = self.j_op(_context)
            ret = j_op
        elif _token == '"beq"':
            beq_op = self.beq_op(_context)
            ret = beq_op
        elif _token == '"bne"':
            bne_op = self.bne_op(_context)
            ret = bne_op
        elif _token == '"blt"':
            blt_op = self.blt_op(_context)
            ret = blt_op
        elif _token == '"la"':
            la_op = self.la_op(_context)
            ret = la_op
        elif _token == '"jal"':
            jal_op = self.jal_op(_context)
            ret = jal_op
        elif _token == '"jr"':
            jr_op = self.jr_op(_context)
            ret = jr_op
        elif _token == '"move"':
            move_op = self.move_op(_context)
            ret = move_op
        elif _token == '"div"':
            div_op = self.div_op(_context)
            ret = div_op
        elif _token == '"mfhi"':
            mfhi_op = self.mfhi_op(_context)
            ret = mfhi_op
        elif _token == '"lw"':
            lw_op = self.lw_op(_context)
            ret = lw_op
        else: # == '"sw"'
            sw_op = self.sw_op(_context)
            ret = sw_op
        end_line = self.end_line(_context)
        return ret

    def immediate(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'immediate', [])
        _token = self._peek('NUM', 'HEX')
        if _token == 'NUM':
            NUM = self._scan('NUM')
            return int(NUM, 10)
        else: # == 'HEX'
            HEX = self._scan('HEX')
            return int(HEX, 16)

    def indirect_address(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'indirect_address', [])
        offset = 0
        if self._peek('NUM', 'LABEL_REF', '"\\\\("') != '"\\\\("':
            _token = self._peek('NUM', 'LABEL_REF')
            if _token == 'NUM':
                NUM = self._scan('NUM')
                offset = NUM
            else: # == 'LABEL_REF'
                LABEL_REF = self._scan('LABEL_REF')
                offset = LABEL_REF
        self._scan('"\\\\("')
        REGISTER = self._scan('REGISTER')
        reg = REGISTER
        self._scan('"\\\\)"')
        return (offset, reg)

    def add_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'add_op', [])
        self._scan('"add"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg2 = REGISTER
        return ADD(dst, reg1, reg2)

    def addi_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'addi_op', [])
        self._scan('"addi"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        immediate = self.immediate(_context)
        imm = immediate
        return ADDI(dst, reg1, imm)

    def li_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'li_op', [])
        self._scan('"li"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        immediate = self.immediate(_context)
        imm = immediate
        return LI(dst, imm)

    def j_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'j_op', [])
        self._scan('"j"')
        LABEL_REF = self._scan('LABEL_REF')
        return JUMP(LABEL_REF)

    def beq_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'beq_op', [])
        self._scan('"beq"')
        REGISTER = self._scan('REGISTER')
        arg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        arg2 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        arg3 = LABEL_REF
        return BEQ(arg1, arg2, arg3)

    def bne_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'bne_op', [])
        self._scan('"bne"')
        REGISTER = self._scan('REGISTER')
        arg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        arg2 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        arg3 = LABEL_REF
        return BNE(arg1, arg2, arg3)

    def blt_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'blt_op', [])
        self._scan('"blt"')
        REGISTER = self._scan('REGISTER')
        arg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        arg2 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        arg3 = LABEL_REF
        return BLT(arg1, arg2, arg3)

    def la_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'la_op', [])
        self._scan('"la"')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        LABEL_REF = self._scan('LABEL_REF')
        address = LABEL_REF
        return LA(reg1, address)

    def jal_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'jal_op', [])
        self._scan('"jal"')
        LABEL_REF = self._scan('LABEL_REF')
        return JAL(LABEL_REF)

    def jr_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'jr_op', [])
        self._scan('"jr"')
        REGISTER = self._scan('REGISTER')
        return JR(REGISTER)

    def move_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'move_op', [])
        self._scan('"move"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        src = REGISTER
        return MOVE(dst, src)

    def div_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'div_op', [])
        self._scan('"div"')
        REGISTER = self._scan('REGISTER')
        reg1 = REGISTER
        self._scan('","')
        REGISTER = self._scan('REGISTER')
        reg2 = REGISTER
        return DIV(reg1, reg2)

    def mfhi_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'mfhi_op', [])
        self._scan('"mfhi"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        return MFHI(dst)

    def lw_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'lw_op', [])
        self._scan('"lw"')
        REGISTER = self._scan('REGISTER')
        dst = REGISTER
        self._scan('","')
        indirect_address = self.indirect_address(_context)
        iaddress = indirect_address
        return LW(dst, iaddress)

    def sw_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, self._pos, 'sw_op', [])
        self._scan('"sw"')
        REGISTER = self._scan('REGISTER')
        src = REGISTER
        self._scan('","')
        indirect_address = self.indirect_address(_context)
        iaddress = indirect_address
        return SW(src, iaddress)


def parse(rule, text):
    P = MipsParser(MipsParserScanner(text))
    return yappsrt.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
